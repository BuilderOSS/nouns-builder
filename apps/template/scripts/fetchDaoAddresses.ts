#!/usr/bin/env npx tsx
/* eslint-disable no-console */

import { PUBLIC_ALL_CHAINS, TESTNET_CHAINS } from '@buildeross/constants/chains'
import { getDAOAddresses, tokenAbi } from '@buildeross/sdk/contract'
import { AddressType, CHAIN_ID } from '@buildeross/types'
import { getProvider } from '@buildeross/utils'
import { config } from 'dotenv'
import { mkdirSync, writeFileSync } from 'fs'
import { join } from 'path'

// Load environment variables from .env.local and .env files
config({ path: ['.env.local', '.env'] })

async function fetchDaoAddresses() {
  // Get environment variables
  const chainId = process.env.NEXT_PUBLIC_CHAIN_ID
  const daoTokenAddress = process.env.NEXT_PUBLIC_DAO_TOKEN_ADDRESS
  const networkType = process.env.NEXT_PUBLIC_NETWORK_TYPE

  if (!chainId) {
    console.error('âŒ NEXT_PUBLIC_CHAIN_ID environment variable is required')
    process.exit(1)
  }

  if (!daoTokenAddress) {
    console.error('âŒ NEXT_PUBLIC_DAO_TOKEN_ADDRESS environment variable is required')
    process.exit(1)
  }

  const parsedChainId = parseInt(chainId) as CHAIN_ID

  if (isNaN(parsedChainId)) {
    console.error('âŒ NEXT_PUBLIC_CHAIN_ID must be a valid number')
    process.exit(1)
  }

  // Validate address format (basic check)
  if (!daoTokenAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
    console.error('âŒ NEXT_PUBLIC_DAO_TOKEN_ADDRESS must be a valid Ethereum address')
    process.exit(1)
  }

  // Find the chain object
  const daoChain = PUBLIC_ALL_CHAINS.find((chain) => chain.id === parsedChainId)

  if (!daoChain) {
    console.error(`âŒ Chain with ID ${parsedChainId} not found in supported chains`)
    console.error(
      '   Supported chains:',
      PUBLIC_ALL_CHAINS.map((c) => `${c.name} (${c.id})`).join(', ')
    )
    process.exit(1)
  }

  if (TESTNET_CHAINS.some((c) => c.id === parsedChainId) && networkType !== 'testnet') {
    console.error(`âŒ NEXT_PUBLIC_NETWORK_TYPE must be "testnet" to use testnet chains`)
    process.exit(1)
  }

  console.log(
    `ğŸ”„ Fetching DAO addresses for chain ${daoChain.name} (${parsedChainId}) and token ${daoTokenAddress}...`
  )

  try {
    // Fetch DAO addresses using the SDK
    const addresses = await getDAOAddresses(parsedChainId, daoTokenAddress as AddressType)

    if (!addresses) {
      console.error('âŒ Could not fetch DAO addresses. This may indicate:')
      console.error('   - The DAO does not exist on this network')
      console.error('   - The token address is incorrect')
      console.error('   - The DAO has not been properly initialized')
      process.exit(1)
    }

    // Fetch DAO name using the token contract
    const provider = getProvider(parsedChainId)
    let daoName = 'DAO' // fallback

    try {
      daoName = (await provider.readContract({
        address: addresses.token,
        abi: tokenAbi,
        functionName: 'name',
      })) as string
      console.log(`âœ… Successfully fetched DAO name: ${daoName}`)
    } catch (error) {
      console.warn('âš ï¸  Could not fetch DAO name, using fallback "DAO"')
    }

    console.log('âœ… Successfully fetched DAO addresses:')
    console.log(`   Chain: ${daoChain.name} (${daoChain.id})`)
    console.log(`   Name: ${daoName}`)
    console.log(`   Token: ${addresses.token}`)
    console.log(`   Auction: ${addresses.auction}`)
    console.log(`   Governor: ${addresses.governor}`)
    console.log(`   Metadata: ${addresses.metadata}`)
    console.log(`   Treasury: ${addresses.treasury}`)

    // Create the config directory if it doesn't exist
    const configDir = join(process.cwd(), 'src/config')
    mkdirSync(configDir, { recursive: true })

    // Create the configuration object
    const config = {
      chainId: parsedChainId,
      addresses,
      name: daoName,
    }

    // Write to static file
    const configPath = join(configDir, 'dao.json')
    writeFileSync(configPath, JSON.stringify(config, null, 2))

    console.log(`ğŸ“ Configuration saved to ${configPath}`)

    // Also create a TypeScript file for easier imports
    const tsConfigContent = `// This file is auto-generated by scripts/fetchDaoAddresses.ts
// Do not edit manually

import { PUBLIC_DEFAULT_CHAINS } from '@buildeross/constants/chains'
import { AddressType, Chain, CHAIN_ID } from '@buildeross/types'
import { RequiredDaoContractAddresses, DaoConfig } from './types'

const DAO_CHAIN_ID: CHAIN_ID = ${parsedChainId}

const DAO_CHAIN: Chain = PUBLIC_DEFAULT_CHAINS.find(
  (chain) => chain.id === DAO_CHAIN_ID
)!

const DAO_ADDRESSES: RequiredDaoContractAddresses = {
  token: '${addresses.token}' as AddressType,
  auction: '${addresses.auction}' as AddressType,
  governor: '${addresses.governor}' as AddressType,
  metadata: '${addresses.metadata}' as AddressType,
  treasury: '${addresses.treasury}' as AddressType,
} as const

export const DAO_CONFIG: DaoConfig = {
  chain: DAO_CHAIN,
  addresses: DAO_ADDRESSES,
  name: '${daoName}',
} as const
`

    const tsConfigPath = join(configDir, 'dao.ts')
    writeFileSync(tsConfigPath, tsConfigContent)

    console.log(`ğŸ“ TypeScript configuration saved to ${tsConfigPath}`)
    console.log('ğŸ‰ DAO configuration setup complete!')
  } catch (error) {
    console.error('âŒ Error fetching DAO addresses:', error)
    process.exit(1)
  }
}

// Run the script
fetchDaoAddresses().catch((error) => {
  console.error('âŒ Unexpected error:', error)
  process.exit(1)
})
