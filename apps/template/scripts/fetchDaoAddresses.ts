#!/usr/bin/env npx tsx
/* eslint-disable no-console */

import { PUBLIC_ALL_CHAINS } from '@buildeross/constants/chains'
import { getDAOAddresses } from '@buildeross/sdk/contract'
import { AddressType, CHAIN_ID } from '@buildeross/types'
import { config } from 'dotenv'
import { mkdirSync, writeFileSync } from 'fs'
import { join } from 'path'

// Load environment variables from .env.local and .env files
config({ path: ['.env.local', '.env'] })

async function fetchDaoAddresses() {
  // Get environment variables
  const chainId = process.env.NEXT_PUBLIC_CHAIN_ID
  const daoTokenAddress = process.env.NEXT_PUBLIC_DAO_TOKEN_ADDRESS

  if (!chainId) {
    console.error('âŒ NEXT_PUBLIC_CHAIN_ID environment variable is required')
    process.exit(1)
  }

  if (!daoTokenAddress) {
    console.error('âŒ NEXT_PUBLIC_DAO_TOKEN_ADDRESS environment variable is required')
    process.exit(1)
  }

  const parsedChainId = parseInt(chainId) as CHAIN_ID

  if (isNaN(parsedChainId)) {
    console.error('âŒ NEXT_PUBLIC_CHAIN_ID must be a valid number')
    process.exit(1)
  }

  // Validate address format (basic check)
  if (!daoTokenAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
    console.error('âŒ NEXT_PUBLIC_DAO_TOKEN_ADDRESS must be a valid Ethereum address')
    process.exit(1)
  }

  // Find the chain object
  const daoChain = PUBLIC_ALL_CHAINS.find((chain) => chain.id === parsedChainId)

  if (!daoChain) {
    console.error(`âŒ Chain with ID ${parsedChainId} not found in supported chains`)
    console.error(
      '   Supported chains:',
      PUBLIC_ALL_CHAINS.map((c) => `${c.name} (${c.id})`).join(', ')
    )
    process.exit(1)
  }

  console.log(
    `ğŸ”„ Fetching DAO addresses for chain ${daoChain.name} (${parsedChainId}) and token ${daoTokenAddress}...`
  )

  try {
    // Fetch DAO addresses using the SDK
    const addresses = await getDAOAddresses(parsedChainId, daoTokenAddress as AddressType)

    if (!addresses) {
      console.error('âŒ Could not fetch DAO addresses. This may indicate:')
      console.error('   - The DAO does not exist on this network')
      console.error('   - The token address is incorrect')
      console.error('   - The DAO has not been properly initialized')
      process.exit(1)
    }

    console.log('âœ… Successfully fetched DAO addresses:')
    console.log(`   Chain: ${daoChain.name} (${daoChain.id})`)
    console.log(`   Token: ${addresses.token}`)
    console.log(`   Auction: ${addresses.auction}`)
    console.log(`   Governor: ${addresses.governor}`)
    console.log(`   Metadata: ${addresses.metadata}`)
    console.log(`   Treasury: ${addresses.treasury}`)

    // Create the config directory if it doesn't exist
    const configDir = join(process.cwd(), 'src/config')
    mkdirSync(configDir, { recursive: true })

    // Create the configuration object (only store chainId in JSON)
    const config = {
      chainId: parsedChainId,
      addresses,
      generatedAt: new Date().toISOString(),
    }

    // Write to static file
    const configPath = join(configDir, 'dao.json')
    writeFileSync(configPath, JSON.stringify(config, null, 2))

    console.log(`ğŸ“ Configuration saved to ${configPath}`)

    // Also create a TypeScript file for easier imports
    const tsConfigContent = `// This file is auto-generated by scripts/fetchDaoAddresses.ts
// Do not edit manually

import { PUBLIC_DEFAULT_CHAINS } from '@buildeross/constants/chains'
import { AddressType, Chain, CHAIN_ID } from '@buildeross/types'

export const DAO_CHAIN_ID: CHAIN_ID = ${parsedChainId}

// Find the chain object from the PUBLIC_DEFAULT_CHAINS array
export const DAO_CHAIN: Chain = PUBLIC_DEFAULT_CHAINS.find(
  (chain) => chain.id === DAO_CHAIN_ID
)!

// Custom type to ensure all addresses are defined (not optional)
export interface RequiredDaoContractAddresses {
  token: AddressType
  auction: AddressType
  governor: AddressType
  metadata: AddressType
  treasury: AddressType
}

export const DAO_ADDRESSES: RequiredDaoContractAddresses = {
  token: '${addresses.token}' as AddressType,
  auction: '${addresses.auction}' as AddressType,
  governor: '${addresses.governor}' as AddressType,
  metadata: '${addresses.metadata}' as AddressType,
  treasury: '${addresses.treasury}' as AddressType,
}

export const DAO_CONFIG = {
  chain: DAO_CHAIN,
  addresses: DAO_ADDRESSES,
  generatedAt: '${config.generatedAt}',
} as const
`

    const tsConfigPath = join(configDir, 'dao.ts')
    writeFileSync(tsConfigPath, tsConfigContent)

    console.log(`ğŸ“ TypeScript configuration saved to ${tsConfigPath}`)
    console.log('ğŸ‰ DAO configuration setup complete!')
  } catch (error) {
    console.error('âŒ Error fetching DAO addresses:', error)
    process.exit(1)
  }
}

// Run the script
fetchDaoAddresses().catch((error) => {
  console.error('âŒ Unexpected error:', error)
  process.exit(1)
})
