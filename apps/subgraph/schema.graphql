type DAO @entity {
  id: ID!
  name: String!
  symbol: String!
  totalSupply: Int!
  description: String!
  contractImage: String!
  projectURI: String!
  tokenAddress: Bytes!
  metadataAddress: Bytes!
  auctionAddress: Bytes!
  treasuryAddress: Bytes!
  governorAddress: Bytes!
  ownerCount: Int!
  voterCount: Int!
  tokensCount: Int!
  proposalCount: Int!
  totalAuctionSales: BigInt!
  auctionConfig: AuctionConfig!
  currentAuction: Auction
  metadataProperties: [MetadataProperty!]
  owners: [DAOTokenOwner!]! @derivedFrom(field: "dao")
  voters: [DAOVoter!]! @derivedFrom(field: "dao")
  tokens: [Token!]! @derivedFrom(field: "dao")
  proposals: [Proposal!]! @derivedFrom(field: "dao")
  auctions: [Auction!]! @derivedFrom(field: "dao")
  daoMultisigUpdates: [DaoMultisigUpdate!]! @derivedFrom(field: "dao")
  pinnedAssets: [TreasuryAssetPin!]! @derivedFrom(field: "dao")
  feedEvents: [FeedEvent!]! @derivedFrom(field: "dao")
  clankerTokens: [ClankerToken!]! @derivedFrom(field: "dao")
  zoraCoins: [ZoraCoin!]! @derivedFrom(field: "dao")
}

type _Schema_
  @fulltext(
    name: "daoSearch"
    language: en
    algorithm: rank
    include: [
      {
        entity: "DAO"
        fields: [
          { name: "name" }
          { name: "symbol" }
          { name: "description" }
          { name: "projectURI" }
        ]
      }
    ]
  )

type DAOTokenOwner @entity {
  id: ID!
  owner: Bytes!
  delegate: Bytes!
  dao: DAO!
  daoTokenCount: Int!
  daoTokens: [Token!]! @derivedFrom(field: "ownerInfo")
}

type DAOVoter @entity {
  id: ID!
  voter: Bytes!
  dao: DAO!
  daoTokenCount: Int!
  daoTokens: [Token!]! @derivedFrom(field: "voterInfo")
}

type Token @entity {
  id: ID!
  name: String!
  image: String
  content: String
  tokenContract: Bytes!
  tokenId: BigInt!
  owner: Bytes!
  ownerInfo: DAOTokenOwner!
  voterInfo: DAOVoter!
  mintedAt: BigInt!
  dao: DAO!
  auction: Auction @derivedFrom(field: "token")
}

type Snapshot @entity {
  id: ID!
  dao: DAO!
  blockNumber: BigInt!
  timestamp: BigInt!
  totalSupply: Int!
  ownerCount: Int!
  voterCount: Int!
  tokensCount: Int!
  proposalCount: Int!
}

type Proposal @entity {
  id: ID!
  proposalId: Bytes!
  proposalNumber: Int!
  dao: DAO!
  targets: [Bytes!]!
  values: [BigInt!]!
  calldatas: String
  title: String
  description: String
  descriptionHash: Bytes!
  proposer: Bytes!
  timeCreated: BigInt!
  executableFrom: BigInt
  expiresAt: BigInt
  againstVotes: Int!
  forVotes: Int!
  abstainVotes: Int!
  voteStart: BigInt!
  voteEnd: BigInt!
  proposalThreshold: BigInt!
  quorumVotes: BigInt!
  queued: Boolean!
  queuedAt: BigInt
  queuedTransactionHash: Bytes
  executed: Boolean!
  executedAt: BigInt
  executionTransactionHash: Bytes
  canceled: Boolean!
  canceledAt: BigInt
  cancelTransactionHash: Bytes
  vetoed: Boolean!
  vetoedAt: BigInt
  vetoTransactionHash: Bytes
  voteCount: Int!
  snapshotBlockNumber: BigInt!
  transactionHash: Bytes!
  votes: [ProposalVote!]! @derivedFrom(field: "proposal")
  updates: [ProposalUpdate!]! @derivedFrom(field: "proposal")
}

type ProposalUpdate @entity {
  id: ID!
  transactionHash: Bytes!
  timestamp: BigInt!
  proposal: Proposal!
  messageType: Int!
  message: String!
  creator: Bytes!
  originalMessageId: Bytes!
  deleted: Boolean!
}

type DaoMultisigUpdate @entity {
  id: ID!
  transactionHash: Bytes!
  timestamp: BigInt!
  daoMultisig: Bytes!
  creator: Bytes!
  dao: DAO!
  deleted: Boolean!
}

type TreasuryAssetPin @entity {
  id: ID!
  transactionHash: Bytes!
  timestamp: BigInt!
  dao: DAO!
  tokenType: Int!
  token: Bytes!
  isCollection: Boolean!
  tokenId: BigInt!
  creator: Bytes!
  revoked: Boolean!
  revokedAt: BigInt
  revokedBy: Bytes
  revokedTxHash: Bytes
}

enum ProposalVoteSupport {
  FOR
  AGAINST
  ABSTAIN
}

type ProposalVote @entity {
  id: ID!
  transactionHash: Bytes!
  timestamp: BigInt!
  voter: Bytes!
  support: ProposalVoteSupport!
  weight: Int!
  reason: String
  proposal: Proposal!
}

type AuctionConfig @entity {
  id: ID!
  duration: BigInt!
  reservePrice: BigInt!
  timeBuffer: BigInt!
  minimumBidIncrement: BigInt!
}

type Auction @entity {
  id: ID!
  dao: DAO!
  startTime: BigInt!
  endTime: BigInt!
  extended: Boolean!
  highestBid: AuctionBid
  winningBid: AuctionBid
  firstBidTime: BigInt
  settled: Boolean!
  bidCount: Int!
  token: Token!
  bids: [AuctionBid!] @derivedFrom(field: "auction")
}

type AuctionBid @entity {
  id: ID!
  transactionHash: Bytes!
  amount: BigInt!
  bidder: Bytes!
  auction: Auction!
  bidTime: BigInt!
}

type MetadataProperty @entity {
  id: ID!
  dao: DAO!
  names: [String!]!
  items: [MetadataItem!]! @derivedFrom(field: "propertyInfo")
  ipfsBaseUri: String!
  ipfsExtension: String!
  createdAt: BigInt!
  deleted: Boolean!
}

type MetadataItem @entity {
  id: ID!
  index: Int!
  propertyInfo: MetadataProperty!
  propertyId: BigInt!
  name: String!
  isNewProperty: Boolean!
}

enum FeedEventType {
  PROPOSAL_CREATED
  PROPOSAL_UPDATED
  PROPOSAL_VOTED
  PROPOSAL_EXECUTED
  AUCTION_CREATED
  AUCTION_BID_PLACED
  AUCTION_SETTLED
  CLANKER_TOKEN_CREATED
  ZORA_COIN_CREATED
}

interface FeedEvent {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
}

type ProposalCreatedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  proposal: Proposal!
}

type ProposalUpdatedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  proposal: Proposal!
  update: ProposalUpdate!
}

type ProposalVotedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  proposal: Proposal!
  vote: ProposalVote!
}

type ProposalExecutedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  proposal: Proposal!
}

type AuctionCreatedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  auction: Auction!
}

type AuctionBidPlacedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  auction: Auction!
  bid: AuctionBid!
}

type AuctionSettledEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  auction: Auction!
  winner: Bytes!
  amount: BigInt!
}

type ClankerTokenCreatedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  clankerToken: ClankerToken!
}

type ZoraCoinCreatedEvent implements FeedEvent @entity {
  id: ID!
  type: FeedEventType!
  dao: DAO!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  actor: Bytes!
  zoraCoin: ZoraCoin!
}

type ClankerToken @entity {
  # ID is the token address (globally unique)
  id: ID!

  # Link to DAO (optional - only if tokenAdmin matches a known DAO treasury)
  dao: DAO

  # Event params
  tokenAddress: Bytes!
  msgSender: Bytes!
  tokenAdmin: Bytes! # The admin address (may or may not be a DAO)

  # Token metadata
  tokenImage: String!
  tokenName: String!
  tokenSymbol: String!
  tokenMetadata: String!
  tokenContext: String!

  # Pool configuration
  startingTick: BigInt!
  poolHook: Bytes!
  poolId: Bytes!
  pairedToken: Bytes!

  # Additional modules
  locker: Bytes!
  mevModule: Bytes!
  extensionsSupply: BigInt!
  extensions: [Bytes!]!

  # Block metadata
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
}

type ZoraCoin @entity {
  # ID is the coin address (globally unique)
  id: ID!

  # Link to ClankerToken (paired currency must be a known ClankerToken)
  clankerToken: ClankerToken

  # Link to DAO (through ClankerToken)
  dao: DAO

  # Event params - indexed
  caller: Bytes!
  payoutRecipient: Bytes!
  platformReferrer: Bytes!

  # Event params - non-indexed
  currency: Bytes!
  uri: String!
  name: String!
  symbol: String!
  coinAddress: Bytes!

  # Pool configuration (PoolKey struct)
  poolCurrency0: Bytes!
  poolCurrency1: Bytes!
  poolFee: BigInt!
  poolTickSpacing: Int!
  poolHooks: Bytes!

  # Pool key hash
  poolKeyHash: Bytes!

  # Version
  version: String!

  # Block metadata
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
}
